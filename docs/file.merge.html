<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: merge
  
    &mdash; Documentation by YARD 0.9.37
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "merge";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: merge</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><p>module Prism<br>
  module Merge<br>
    VERSION: String</p>

<pre class="code ruby"><code class="ruby">module Version
  VERSION: String
end

class Error &lt; StandardError
end

class ParseError &lt; Error
  attr_reader content: String
  attr_reader parse_result: untyped

  def initialize: (String message, content: String, parse_result: untyped) -&gt; void
end

class TemplateParseError &lt; ParseError
end

class DestinationParseError &lt; ParseError
end

class FileAnalysis
  FREEZE_START: Regexp
  FREEZE_END: Regexp
  FREEZE_BLOCK: Regexp

  type freeze_block = {
    range: Range[Integer],
    line_range: Range[Integer],
    text: String,
    start_marker: String?
  }

  type node_info = {
    node: untyped,
    index: Integer,
    leading_comments: Array[untyped],
    inline_comments: Array[untyped],
    signature: Array[untyped]?,
    line_range: Range[Integer]
  }

  attr_reader content: String
  attr_reader parse_result: untyped
  attr_reader lines: Array[String]
  attr_reader statements: Array[untyped]
  attr_reader freeze_blocks: Array[freeze_block]

  def initialize: (String content, ?signature_generator: (^(untyped) -&gt; Array[untyped])?) -&gt; void

  def valid?: () -&gt; bool

  def extract_statements: () -&gt; Array[untyped]

  def extract_freeze_blocks: () -&gt; Array[freeze_block]

  def line_to_node_map: () -&gt; Hash[Integer, Array[untyped]]

  def node_to_line_map: () -&gt; Hash[untyped, Range[Integer]]

  def nodes_with_comments: () -&gt; Array[node_info]

  def comment_map: () -&gt; Hash[Integer, Array[untyped]]

  def signature_at: (Integer index) -&gt; Array[untyped]?

  def generate_signature: (untyped node) -&gt; Array[untyped]?

  def in_freeze_block?: (Integer line_num) -&gt; bool

  def freeze_block_at: (Integer line_num) -&gt; freeze_block?

  def normalized_line: (Integer line_num) -&gt; String?

  def line_at: (Integer line_num) -&gt; String?

  private

  def build_line_to_node_map: () -&gt; Hash[Integer, Array[untyped]]

  def build_node_to_line_map: () -&gt; Hash[untyped, Range[Integer]]

  def extract_nodes_with_comments: () -&gt; Array[node_info]

  def find_leading_comments: (untyped current_stmt, untyped? prev_stmt, untyped body_node) -&gt; Array[untyped]

  def inline_comments_for_node: (untyped stmt) -&gt; Array[untyped]

  def build_comment_map: () -&gt; Hash[Integer, Array[untyped]]

  def default_signature: (untyped node) -&gt; Array[untyped]
end

class FileAligner
  class Anchor &lt; Struct[untyped]
    attr_accessor template_start: Integer
    attr_accessor template_end: Integer
    attr_accessor dest_start: Integer
    attr_accessor dest_end: Integer
    attr_accessor match_type: Symbol
    attr_accessor score: Integer

    def template_range: () -&gt; Range[Integer]

    def dest_range: () -&gt; Range[Integer]

    def length: () -&gt; Integer
  end

  class Boundary &lt; Struct[untyped]
    attr_accessor template_range: Range[Integer]?
    attr_accessor dest_range: Range[Integer]?
    attr_accessor prev_anchor: Anchor?
    attr_accessor next_anchor: Anchor?

    def template_lines: () -&gt; Array[Integer]

    def dest_lines: () -&gt; Array[Integer]
  end

  attr_reader template_analysis: FileAnalysis
  attr_reader dest_analysis: FileAnalysis
  attr_reader anchors: Array[Anchor]
  attr_reader boundaries: Array[Boundary]

  def initialize: (FileAnalysis template_analysis, FileAnalysis dest_analysis) -&gt; void

  def align: () -&gt; Array[Boundary]

  private

  def find_anchors: () -&gt; void

  def build_line_map: (FileAnalysis analysis) -&gt; Hash[Integer, String]

  def find_exact_line_matches: (Hash[Integer, String] template_map, Hash[Integer, String] dest_map) -&gt; Array[Hash[Symbol, untyped]]

  def merge_consecutive_matches: (Array[Hash[Symbol, untyped]] matches) -&gt; Array[Anchor]

  def add_node_signature_anchors: () -&gt; void

  def add_freeze_block_anchors: () -&gt; void

  def compute_boundaries: () -&gt; void

  def ranges_overlap?: (Range[Integer]? range1, Range[Integer]? range2) -&gt; bool
end

class MergeResult
  DECISION_KEPT_TEMPLATE: Symbol
  DECISION_KEPT_DEST: Symbol
  DECISION_APPENDED: Symbol
  DECISION_REPLACED: Symbol
  DECISION_FREEZE_BLOCK: Symbol

  type line_metadata = {
    decision: Symbol,
    template_line: Integer?,
    dest_line: Integer?,
    comment: String?,
    result_line: Integer
  }

  attr_reader lines: Array[String]
  attr_reader line_metadata: Array[line_metadata]

  def initialize: () -&gt; void

  def add_line: (String content, decision: Symbol, ?template_line: Integer?, ?dest_line: Integer?, ?comment: String?) -&gt; void

  def add_lines_from: (Array[String] source_lines, decision: Symbol, source: Symbol, start_line: Integer, ?comment: String?) -&gt; void

  def add_node: (FileAnalysis::node_info node_info, decision: Symbol, source: Symbol, ?source_analysis: FileAnalysis?) -&gt; void

  def to_s: () -&gt; String

  def statistics: () -&gt; Hash[Symbol, Integer]

  def lines_by_decision: (Symbol decision) -&gt; Array[line_metadata]

  def debug_output: () -&gt; String
end

class ConflictResolver
  type boundary_content = {
    lines: Array[String],
    nodes: Array[FileAnalysis::node_info],
    has_freeze_block: bool,
    line_range: Range[Integer]?
  }

  attr_reader template_analysis: FileAnalysis
  attr_reader dest_analysis: FileAnalysis
  attr_reader signature_match_preference: Symbol
  attr_reader add_template_only_nodes: bool

  def initialize: (FileAnalysis template_analysis, FileAnalysis dest_analysis, ?signature_match_preference: Symbol, ?add_template_only_nodes: bool) -&gt; void

  def resolve: (FileAligner::Boundary boundary, MergeResult result) -&gt; void

  private

  def extract_boundary_content: (FileAnalysis analysis, Range[Integer]? line_range) -&gt; boundary_content

  def ranges_overlap?: (Range[Integer] range1, Range[Integer] range2) -&gt; bool

  def add_content_to_result: (boundary_content content, MergeResult result, Symbol source, Symbol decision) -&gt; void

  def merge_boundary_content: (boundary_content template_content, boundary_content dest_content, FileAligner::Boundary boundary, MergeResult result) -&gt; void

  def build_signature_map: (Array[FileAnalysis::node_info] nodes) -&gt; Hash[Array[untyped], Array[FileAnalysis::node_info]]

  def add_line_safe: (MergeResult result, String content, **untyped kwargs) -&gt; void

  def handle_orphan_lines: (boundary_content template_content, boundary_content dest_content, MergeResult result) -&gt; void

  def find_orphan_lines: (FileAnalysis analysis, Range[Integer]? line_range, Array[FileAnalysis::node_info] nodes) -&gt; Array[Integer]
end

class SmartMerger
  attr_reader template_analysis: FileAnalysis
  attr_reader dest_analysis: FileAnalysis
  attr_reader aligner: FileAligner
  attr_reader resolver: ConflictResolver
  attr_reader result: MergeResult

  type merge_debug_result = {
    content: String,
    debug: String,
    statistics: Hash[Symbol, Integer]
  }

  def initialize: (
    String template_content,
    String dest_content,
    ?signature_generator: (^(untyped) -&gt; Array[untyped])?,
    ?signature_match_preference: Symbol,
    ?add_template_only_nodes: bool
  ) -&gt; void

  def merge: () -&gt; String

  def merge_with_debug: () -&gt; merge_debug_result

  private

  def process_merge: (Array[FileAligner::Boundary] boundaries) -&gt; void

  def build_timeline: (Array[FileAligner::Boundary] boundaries) -&gt; Array[Hash[Symbol, untyped]]

  def process_anchor: (FileAligner::Anchor anchor) -&gt; void

  def add_freeze_block_from_dest: (FileAligner::Anchor anchor) -&gt; void

  def add_signature_match_from_dest: (FileAligner::Anchor anchor) -&gt; void

  def add_exact_match_from_template: (FileAligner::Anchor anchor) -&gt; void

  def process_boundary: (FileAligner::Boundary boundary) -&gt; void
end   end end
</code></pre>
</div></div>

      <div id="footer">
  Generated on Thu Dec  4 05:33:05 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.37 (ruby-3.4.7).
</div>

    </div>
  </body>
</html>